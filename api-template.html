
{{define "entry"}}
	<p><span style="color:#000088; font-size:1.3em"> <b>{{.Name}}</b>{{.Ins}} </span> 
	{{with .Doc}} <p style="margin-left:40px"> {{.}} </p> {{end}}

	{{with .Methods}} 
		<p style="margin-left:40px"> <span style="color:grey"> <b>methods:</b> 
		{{range .}} {{.}} &nbsp;{{end}} 
		</span> </p> 
	{{end}}

	{{with .Examples}} <p style="margin-left:40px; color:grey"> examples: 
		{{range .}} 
			<a href="examples.html#example{{.}}">[{{.}}]</a> 
		{{end}} 
		</p> 
	{{end}}

	</p>
{{end}}


{{.Include "head.html"}}

<h1> mumax<sup>3</sup> API </h1>

This is a complete overview of all available functions for writing an input script.

<hr/><h1> Syntax </h1>

<p>
The mumax<sup>3</sup> input syntax is a subset of <a href=http://golang.org>Go</a>'s syntax, somewhat similar to C. It is case-independent however, so msat is the same as Msat or MSAT.</p>

<h3>Defining variables</h3>

New variables are declared using <code>:=</code>. Variables have a fixed type, inferred from the declaration's right-hand-side. Assigning to existing variables is done using <code>=</code>. E.g.:

<pre><code>i := 7         // defines a new variable i, type automatically detected to be int
print(i)       // now we can use i
i = 5          // assign new value, don't use ':=' (attempt to re-declare)

str := "hello" // defines str, type automatically is string
//str = 1      // would fail, cannot assign int to string
</code></pre>

<h3>Arithmetic</h3>
Most common arithmetic operations are possible. Also Go's <a href=http://golang.org/pkg/math>math</a> library and some common constants are available. For raise-to-the-power, pow(x,y) should be used.

<pre><code>x := pi*(3+4)/5
x = pow(x, 3)
x++
y := abs(cbrt(cosh(erf(erfc(gamma(J0(Y0(2))))))))
</code></pre>

<h3>Control structures</h3>
Loops are possible as well:
<pre><code>for i:=0; i<10; i++{
	print(i)
}
</code></pre>

<h3>Implicit functions</h3>

Some of the API features accept a function as argument (e.g.: <code>RunWhile(func()bool)</code>, or all input parameters). In that case, and <i>only</i> in this case, the argument is implicitly converted to a function, which is re-evaluated each time it's needed. E.g.:

<pre><code>
value := sin(pi*t)  // value is a float64, RHS evaluated only once
Msat = value        // time-independent Msat
</code></pre>
versus:
<pre><code>
Msat = sin(pi*t)    // RHS converted to function, re-evaluted every time
</code></pre>


<hr/><h1> Setting  the mesh size</h1>
The simulation mesh defines the size of the box around your magnet. It should be set at the beginning of the script. The number of cells should preferably be powers of two, or at least have small prime factors (2,3,5,7). E.g.:
<pre><code>Nx := 128
Ny := 64
Nz := 2
sizeX := 500e-9
sizeY := 250e-9
sizeZ := 10e-9
SetGridSize(Nx, Ny, Nz)
SetCellSize(sizeX/Nx, sizeY/Ny, sizeZ/Nz)
</code></pre>

{{range .FilterName "setgridsize" "setcellsize"}} {{template "entry" .}} {{end}}


<hr/><h1> Setting a geometry </h1>

Optionally a magnet Shape other than the full simulation box can be specified. One can specify primitive shapes, constructed at the origin (box center), and translate/rotate them if needed. E.g.:
<pre><code> SetGeom(cylinder(400e-9, 20e-9).RotX(45*pi/180).Transl(1e-6,0,0))
</code></pre>

{{range .FilterName "setgeom"}} {{template "entry" .}} {{end}}
{{range .FilterReturn "Shape"}} {{template "entry" .}} {{end}}


<hr/><h1> Defining regions </h1>
Optionally, up to 256 regions can be defined. Each cell is associated with exactly one region and is assigned assigned to region 0 by default. Each region can have its own material parameters. E.g.:
<pre><code>DefRegion(1, circle(1e-6))
DefRegion(0, circle(1e-6).Inverse()) // redundant
</code></pre>

{{range .FilterName "DefRegion" "DefRegionCell"}} {{template "entry" .}} {{end}}


<hr/><h1> Initial magnetization </h1>

The initial magnetization is set by assigning a <code>Config</code> to m, setting it in separate regions, or by loading a file directly.
<pre><code>m = uniform(1, 0, 0)
m.SetRegion(1, vortex(1, 1))
m.LoadFile("config.dump")
</code></pre>

{{range .FilterName "m"}} {{template "entry" .}} {{end}}
{{range .FilterReturn "Config"}} {{template "entry" .}} {{end}}


<hr/><h1> Material parameters </h1>

Assigning to a material parameter sets a value in all regions. E.g.:
<pre><code>Msat  = 800e3
AnisU = vector(1, 0, 0)
</code></pre>

When regions are defined, they can also be set region-wise:
<pre><code>Msat.SetRegion(0, 800e3)
Msat.SetRegion(1, 540e3)
</code></pre>

Material parameters can be functions of time as well. E.g.:
<pre><code>f := 500e6
Ku1 = 500 * sin(2*pi*f*t)
</code></pre>

{{range .FilterType "*engine.ScalarParam" "*engine.VectorParam"}} {{template "entry" .}} {{end}}


<hr/><h1> Excitation </h1>

Field or current excitations can be set in the same way as material parameters:
<pre><code>B_ext = vector(0.01, 1e-6*sin(2*pi*f*t), 0)
B_ext.SetRegion(1, vector(0, 0, 0.1))
</code></pre>
Additionally, an arbitrary number of time- and space-dependent vector fields of the form <code> g(x,y,z) * f(t) </code> may be added. (E.g., to simulate the field of an antenna or an arbitrary current running through the magnet)
<pre><code>B_ext.Add(LoadFile("antenna.dump"), sin(2*pi*f*t))
JPol.Add(LoadFile("current.dump"), 1)
</code></pre>

{{range .FilterType "*engine.Excitation"}} {{template "entry" .}} {{end}}
{{range .FilterName "LoadFile"}} {{template "entry" .}} {{end}}

<hr/><h1> Output quantities </h1>

{{range .FilterType "*engine.setter" "*engine.adder" "*engine.buffered" "*engine.GetScalar" "*engine.GetVector" "*engine.FFTM" "*engine.Regions"}} {{template "entry" .}} {{end}}


<hr/><h1> Scheduling output </h1>

All input and output quantities (as described above) can be saved in a space-dependent way (".dump" file), or as spatial averages (table output). The data table ("table.txt") contains by default the time and average magnetization. More coulumns can be added with <code>TableAdd()</code>.
<pre><code>save(B_ext)

tableadd(B_ext)
tablesave()
</code></pre>
Optionally, the output/averaging can be done over a single region:
<pre><code>save(m.Region(1))
tableadd(m.Region(1)) 
</code></pre>

{{range .FilterName "tableadd" "tablesave" "tableautosave" "save" "saveas" "autosave"}} {{template "entry" .}} {{end}}

<hr/><h1> Running </h1>

<code>Run(time)</code> runs the simulation for a given time in seconds, using sensible error settings. 
<pre><code>Run(1e-9)
</code></pre>
More fine-grained control is provided by <code>RunWhile(<i>condition</i>)</code>, which runs as long as an arbitrary condition is met. E.g.: 
<pre><code>RunWhile(MaxTorque &gt; 1e-4)  // handy for relax
RunWhile(average(m)[0] &lt; 0.1)   // handy during reversal etc.
</code></pre>
Optionally, the solver accuracy may be fine-tuned. E.g.:
<pre><code>MaxDt = 1e-12
MinDt = 1e-15
MaxErr = 1e-6
</code></pre>
Also optionally, a different solver may be chosen (at any point) with <code>SetSolver(int)</code>. Currently available solver types:
<ul>
	<li> <code>1</code>: Euler solver (requires <code>FixDt = ...</code>, ignores other settings) </li>
	<li> <code>2</code>: Adaptive Heun solver (default) </li> 
</ul>
E.g.:
<pre><code>SetSolver(1) // Euler
FixDt = 1e-15
</code></pre>

{{range .FilterName "run" "steps" "runwhile"}} {{template "entry" .}} {{end}}
{{range .FilterName "t" "dt" "MinDt" "MaxDt" "FixDt" "HeadRoom" "MaxErr"}} {{template "entry" .}} {{end}}
{{range .FilterName "SetSolver"}} {{template "entry" .}} {{end}}

<hr/><h1> Extensions </h1>

Extensions are extra functionalities that are not officially supported. They are aimed at rather specific problems and may not work as expected for your particular situation. Their API and functionality may change in future releases.

{{range .FilterPrefix "ext_"}} {{template "entry" .}} {{end}}
{{range .FilterName "enabledemag" "average" "fprintln" "setexlen" "expect" "PostStep"}} {{template "entry" .}} {{end}}

<hr/><h1> Misc </h1>
Other available functions.
{{range .FilterLeftovers}} {{template "entry" .}} {{end}}

</body>

